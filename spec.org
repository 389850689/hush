* /Hush/
  /Hush/ is a /Unix/ shell language inspired by the /[[http://www.lua.org/][Lua/ programming language]]. Currently in
  development.

  This is the technical specification for /Hush/, defining the complete syntax and semantics of the language.
** Foreword
   /Hush/ is motivated by some shortcomings in traditional shell languages, mainly the lack
   of appropriate primitive data structures, such as generic arrays and maps. Such
   shortcomings result in hacky workarounds for simple tasks, and render complicated tasks
   being rather tricky to implement.

   /Hush/ borrows a great part of it's design from /Lua/, a simple but elegant scripting
   language. /Lua/ has proved to be a very expressive programming language, regardless of
   it's succinct syntax and semantics, particularly it's very simple type system.
** Syntax
   As /Hush/ is heavily inspired by /Lua/, it borrows most of the syntax from it, with only
   minor tweaks to support the additional command invocation syntax.
** Type system
   As in /Lua/, /Hush/ proposes a handfull of built-in types, and no user-defined types. This
   makes the type system extremely simple, without compromising expressiveness. The types
   proposed by /Hush/ are:
   - nil :: the unit type, usually for representing missing values. It's only value is ~nil~.
   - bool :: the boolean type, composed of the values ~true~ and ~false~.
   - char :: a C-like unsigned char type, 0-255.
   - int  :: a 64 bit integer type.
   - float :: a 64 bit floating point type.
   - array :: a heterogeneous array, 0-indexed unlike in /Lua/.
   - dict :: a heterogeneous hash map.
   - function :: a callable function.
   A string for instance is nothing but an ~array~ of ~char~.
** Basic constructs
*** Functions
    In /Hush/, functions:
    - Can have an arbitrary number of parameters, but returns only one value, in contrast to
      /Lua/.
    - Are values, being first class citizens like every other type in the language.
    - As they are values, they have no name. A function declared with a name is actually a
      variable declaration, referring to such function value. Therefore, such variable can
      be reassigned to a different value.
    - Can be called using the ~()~ operator, which encompasses up to two comma-separated
      lists of arguments, divided by a semicolon. The first list, if any, denotes required
      arguments. The second list, if any, denotes optional arguments. If a function is
      called with missing required arguments, then a /panic/ occurs. Optional arguments
      default to ~nil~.
    - Can also capture variables, i.e. they can be closures.
    - Can be recursive. As functions are values, recursive functions are actually closures
      on themselves.
    - Have access to a special variable, ~self~, which is a reference to the function's
      parent, if any. If a function is called directly as ~my_function()~, then ~self~ is
      ~nil~. Otherwise, if it's called as a member of a ~dict~, as in ~my_obj.my_function()~,
      then ~self~ refers to the same value as ~my_obj~.

    Summarizing, here are some examples of functions in /Hush/:
    #+begin_src lua
      -- Simple function definition.
      function sum(a, b, c)
        return a + b + c
      end


      -- Reassigns the sum variable, which was referring to the previous function.
      sum = function (a, b, c; d) -- Here, `d` is an optional argument.
        if d != nil then
          return a + b + c + d
        else
          return a + b + c
        end
      end


      function sum(a)
        return function(b) -- Closure!
          return a + b  -- Here, `a` is captured from the outer scope.
        end
      end


      -- Simple recursive function.
      function factorial(n)
        if n < 2 then
          return 1
        else
          return n * factorial(n - 1)
        end
      end


      -- A member function.
      my_obj = [
        value: 5,

        method: function()
          if self != nil then
            return self.value
          else
            return 0
          end
        end,
      ]

      my_obj.method() -- Returns 5

      fun = my_obj.method

      fun() -- Returns 0
    #+end_src
*** Expressions
    In traditional shells, expressions produce two results that can be manipulated by the
    language: the standard output (/stdin/stderr/), and a status code. The output can be
    captured by the ~$()~ operator, and the status code is immediately available through the
    ~$?~ variable. Function and command arguments are always strings, and the status code is
    always an integer.

    /Hush/ proposes more generic semantics, which are tipically adopted by general purpose
    programming languages. Functions should be able to accept parameters of arbitrary
    types, and also be able to return a value of an arbitrary type. On the other hand,
    commands are limited by the operating system to accept strings and return a status
    code. Therefore, when invoking external commands, /Hush/ converts the given arguments to
    strings, and provides the status code as the return value.

    The expression composed by a function or command call results in the returned value,
    rendering a variable like ~$?~ unnecessary. As for the capture operator (~${}~ in /Hush/),
    more flexible semantics are adopted. Instead of resulting in the expression's /stdout/,
    the result is a ~dict~ containing three fields: a handle for /stdout/, a handle for /stderr/,
    and the status code. This enables acessing both /stdout/ and /stderr/ separately, as well
    as the status code, all with value semantics. If one cares only about the /stdout/ for
    instance, direct access can be used, without requiring any intermediate variables:
    #+begin_src bash
      ${date --iso-8061}.stdout
    #+end_src
*** Commands
    In /Hush/, command blocks are enclosed in ~{}~. Individual commands must end with a
    semicolon, except for the last command in the block. This can be annoying for simple
    commands, but it allows one to split a command across multiple lines interspersed
    with comments, which is currently impossible in /Bash/, for instance.
    #+begin_src bash
      {
        docker create
               --name $container
               -i -a STDIN -a STDOUT -a STDERR # attach all stdio
               -v $(pwd):/my/project:ro # mount the source code as a read-only volume
               my-image:latest;


        rsync -av --delete --delete-excluded
               # version control directories:
               --exclude='.git/'
               --exclude='.svn/'
               # build directories:
               --exclude='.stack-work/'
               --exclude='.ccls-cache/'
               --exclude='target/'
               --exclude='bin/'
               --exclude='obj/'
               # don't backup series or torrents:
               --exclude='series/'
               --exclude='torrents/'
               ~/ /mnt/backup 2>&1
          | tee $(date '+%Y-%m-%dT%H.%M.%S-rsync.log');


        list-musics
          | xargs --null -- mediainfo --Output='Audio;%Duration%\n' # get duration in miliseconds
          | awk NF # remove empty lines
          | paste -s -d + # join lines with +
          | bc # eval the resulting expression
      }
    #+end_src

    As noted previously, command invocation expressions result in the status code of the
    last command in the block. If such status indicates a failure (non-zero), and is not
    immediately assigned to a variable or captured with ~${}~, /Hush/ will automatically panic,
    halting the script execution. This behavior is similar to /Bash/'s ~set -e~.
** Object model
   /Hush/ mainly focuses on functional programming, but also supports some sort of object
   oriented programming. While /Lua/ proposes the /metatable/ mechanism to add sofisticated dynamics
   to /tables/, /Hush/ adopts simpler semantics, having /dicts/ as plain key-value stores.

   Functions can act as methods by using the ~self~ operator, as described
   previously. Objects can be defined as /dicts/ with member functions, which can be defined
   by a constructor function.

   Hush:
   #+begin_src lua
     function MyCounter(initial_value) -- MyCounter is a function that represents a Class.
       increment = function()
         self._value += 1
       end

       get = function()
         return self._value
       end

       return [
         _value: initial_value, -- Public field.
         -- These methods could be implemented here as well.
         -- Remeber, functions are nothing but values.
         increment: increment, -- Method
         get: get,             -- Method
       ]
     end


     counter = MyCounter(0)
     counter.increment()
     counter.increment()
     counter.get() -- Returns 2


     function StepCounter(initial_value, step)
       -- This function captures the `step` variable, which acts as a private field.
       increment = function()
         self._value += step
       end

       print = function()
         print(self.get())
       end

       counter = MyCounter(initial_value) -- Inheritance
       counter.print = print -- Additional method
       counter.increment = increment -- Method overriding
       return counter
     end


     counter = StepCounter(0, 2)
     counter.increment()
     counter.increment()
     counter.print() -- Prints 4
   #+end_src
