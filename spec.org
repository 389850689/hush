* /Hush/
  /Hush/ is a /Unix/ shell language inspired by the /[[http://www.lua.org/][Lua/ programming language]]. Currently in
  development.

  This is the technical specification for /Hush/, defining the complete syntax and semantics of the language.
** Foreword
   /Hush/ is motivated by some shortcomings in traditional shell languages, mainly the lack
   of appropriate primitive data structures, such as generic arrays and maps. Such
   shortcomings result in hacky workarounds for simple tasks, and render complicated tasks
   being rather tricky to implement.

   /Hush/ borrows a great part of it's design from /Lua/, a simple but elegant scripting
   language. /Lua/ has proved to be a very expressive programming language, regardless of
   it's succinct syntax and semantics, particularly it's very simple type system.
** Type system
   As in /Lua/, /Hush/ proposes a handfull of built-in types, and no user-defined types. This
   makes the type system extremely simple, without compromising expressiveness. The types
   proposed by /Hush/ are:
   - nil :: the unit type, usually for representing missing values.
   - bool :: the boolean type.
   - char :: a C-like unsigned char type, 0-255.
   - int  :: a 64 bit integer type.
   - float :: a 64 bit floating point type.
   - array :: a heterogeneous array, 0-indexed unlike in /Lua/.
   - dict :: a heterogeneous hash map.
   - function :: a callable function.
   A string for instance is nothing but an ~array~ of ~char~.
** Syntax
   As /Hush/ is heavily inspired by /Lua/, it borrows most of the syntax from it, with only
   minor tweaks to support the additional command invocation syntax.
*** Identifiers
    Identifiers in /Hush/ are case sensitive, composed by alphanumeric or underscore
    characters, and must not start with a number. The only exception is the keywords,
    which are not valid identifiers.
*** Keywords
    The following are keywords in /Hush/:
    : let, if, then, else, end, for, in, do, while, function, return, not, and, or, true,
    : false, nil, break
*** Literals
    Each type in the language has corresponding syntax for literals. Although strings are
    arrays of =char=, they also have special syntax for literals.
    - nil :: It's only value is ~nil~.
    - bool :: ~true~ and ~false~.
    - char :: a single char enclosed in single quotes.
    - int  :: 64 bit decimal integer literal, optionally prefixed by a minus sign.
    - float :: 64 bit floating point literal: a decimal followed by a period character,
      followed by another decimal literal, with an optional exponent.
    - array :: values enclosed in =[]=.
    - dict :: identifier-expression pairs enclosed in =#[]=, separated by a colon and
      delimited by commas.
    - function :: =function (<args>) <body> end=

    Example:
    #+begin_src lua
      let my_dict = #[ -- dict
        field0: nil,
        field1: true,
        field2: 42, -- integer
        field3: -12, -- integer
        field4: 3.14, -- float
        field5: 12E+99, -- float
        field6: [ -- array
          "a string",
          'c', -- a char
          '\n' -- another char
        ],
        field7: function (arg1, arg2)
          return arg1 + arg2
        end
      ]
    #+end_src
** Constructs
*** Variables
    /Hush/ adopts static scope, and variables must be declared with a `let` statement.
    #+begin_src lua
      let x -- Introduces the variable in the local scope
      let y = 5 -- Shortcut for assignment
    #+end_src
*** Conditionals and loops
    In /Hush/ conditional statements don't coerce types to =bool=. This means that one cannot
    have =nil= or an empty array as conditions, like in /Lua/. All conditionals operate with a
    =bool=. If one supplies a condition that is not a boolean, a panic occurs.

    The =if= statement can have two forms:
    #+begin_src lua
      if expression then
        -- body
      end

      if expression then
        -- body
      else
        -- body
      end
    #+end_src
    The =if=-=else= form is a valid expression, and results in the value of the respective
    body. If the body ends with a statement that produces no value, then =nil= is produced.

    The =while= loop allows looping over a boolean expression:
    #+begin_src lua
      while expression do
        -- body
      end
    #+end_src

    The =for= loop allows looping over an interator function:
    #+begin_src lua
      for variable in expression do
        -- body
      end
    #+end_src
    Here, =expression= must result in a function that can be called once for every
    iteration, receiving no arguments and returning an array with two elements. The first
    element *must* be a boolean. When =true=, the second element is assigned to the iteration
    variable, and the loop body is executed. When =false=, the iteration is finished.

    Under the hood, the =for= loop translates to something like:
    #+begin_src lua
      let iter = expression
      let arr = iter()
      while arr[0] do
        let variable = arr[1]
        -- body
        arr = iter()
      end
    #+end_src

    Both loop constructs support the =break= keyword, which implements short exiting.
*** Functions
    In /Hush/, functions:
    - Can have an arbitrary number of parameters, but returns only one value, in contrast to
      /Lua/.
    - Are values, being first class citizens like every other type in the language.
    - As they are values, they have no name. A function declared with a name is actually a
      variable declaration, referring to such function value. Therefore, such variable can
      be reassigned to a different value.
    - Can be called using the ~()~ operator, which encompasses up to two comma-separated
      lists of arguments, divided by a semicolon. The first list, if any, denotes required
      arguments. The second list, if any, denotes optional arguments. If a function is
      called with missing required arguments, then a /panic/ occurs. Optional arguments
      default to ~nil~.
    - Can also capture variables, i.e. they can be closures.
    - Can be recursive. As functions are values, recursive functions are actually closures
      on themselves.
    - Have access to a special variable, ~self~, which is a reference to the function's
      parent, if any. If a function is called directly as ~my_function()~, then ~self~ is
      ~nil~. Otherwise, if it's called as a member of a ~dict~, as in ~my_obj.my_function()~,
      then ~self~ refers to the same value as ~my_obj~.

    Summarizing, here are some examples of functions in /Hush/:
    #+begin_src lua
      -- Simple function definition.
      function sum(a, b, c)
        return a + b + c
      end


      -- Reassigns the sum variable, which was referring to the previous function.
      sum = function (a, b, c; d) -- Here, `d` is an optional argument.
        if d != nil then
          return a + b + c + d
        else
          return a + b + c
        end
      end


      function sum(a)
        return function(b) -- Closure!
          return a + b  -- Here, `a` is captured from the outer scope.
        end
      end


      -- Simple recursive function.
      function factorial(n)
        if n < 2 then
          return 1
        else
          return n * factorial(n - 1)
        end
      end


      -- A member function.
      my_obj = #[
        value: 5,

        method: function()
          if self != nil then
            return self.value
          else
            return 0
          end
        end,
      ]

      my_obj.method() -- Returns 5

      fun = my_obj.method

      fun() -- Returns 0
    #+end_src
*** Expressions
    In traditional shells, expressions produce two results that can be manipulated by the
    language: the standard output (/stdin/stderr/), and a status code. The output can be
    captured by the ~$()~ operator, and the status code is immediately available through the
    ~$?~ variable. Function and command arguments are always strings, and the status code is
    always an integer.

    /Hush/ proposes more generic semantics, which are tipically adopted by general purpose
    programming languages. Functions should be able to accept parameters of arbitrary
    types, and also be able to return a value of an arbitrary type. On the other hand,
    commands are limited by the operating system to accept strings and return a status
    code. Therefore, when invoking external commands, /Hush/ converts the given arguments to
    strings, and provides the status code as the return value.

    The expression composed by a function or command call results in the returned value,
    rendering a variable like ~$?~ unnecessary. As for the capture operator (~${}~ in /Hush/),
    more flexible semantics are adopted. Instead of resulting in the expression's /stdout/,
    the result is a ~dict~ containing three fields: a handle for /stdout/, a handle for /stderr/,
    and the status code. This enables acessing both /stdout/ and /stderr/ separately, as well
    as the status code, all with value semantics. If one cares only about the /stdout/ for
    instance, direct access can be used, without requiring any intermediate variables:
    #+begin_src bash
      ${date --iso-8061}.stdout
    #+end_src
*** Commands
    In /Hush/, command blocks are enclosed in ~{}~. Individual commands must end with a
    semicolon, except for the last command in the block. This can be annoying for simple
    commands, but it allows one to split a command across multiple lines interspersed
    with comments, which is currently impossible in /Bash/, for instance.
    #+begin_src bash
      {
        docker create
               --name $container
               -i -a STDIN -a STDOUT -a STDERR # attach all stdio
               -v $(pwd):/my/project:ro # mount the source code as a read-only volume
               my-image:latest;


        rsync -av --delete --delete-excluded
               # version control directories:
               --exclude='.git/'
               --exclude='.svn/'
               # build directories:
               --exclude='.stack-work/'
               --exclude='.ccls-cache/'
               --exclude='target/'
               --exclude='bin/'
               --exclude='obj/'
               # don't backup series or torrents:
               --exclude='series/'
               --exclude='torrents/'
               ~/ /mnt/backup 2>&1
          | tee $(date '+%Y-%m-%dT%H.%M.%S-rsync.log');


        list-musics
          | xargs --null -- mediainfo --Output='Audio;%Duration%\n' # get duration in miliseconds
          | awk NF # remove empty lines
          | paste -s -d + # join lines with +
          | bc # eval the resulting expression
      }
    #+end_src

    As noted previously, command invocation expressions result in the status code of the
    last command in the block. If such status indicates a failure (non-zero), and is not
    immediately assigned to a variable or captured with ~${}~, /Hush/ will automatically panic,
    halting the script execution. This behavior is similar to /Bash/'s ~set -e~.
**** Asynchronous commands
     Shells like /Ksh/, /Zsh/ and /Bash/ support asynchronous commands through the =coproc=
     keyword and the =&= operator, also providing the =wait= builtin for joining such
     coprocesses. In such shells, the /pid/ of a asynchronous command is immediately
     available through the =$!= variable.

     Bash:
     #+begin_src bash
       # Array variable to capture the pids of all spawned tasks
       declare -A pids

       one long running command &
       pids+=($!)

       another long running command &
       pids+=($!)

       yet another long running command &
       pids+=($!)

       # Give jobs some time to complete
       sleep 2000

       status=0

       for pid in $pids; do
         if ps -p $pid > /dev/null; then
           # Job is stil running, abort...
           kill $pid
           status=1
         else
           # Job finished, check if succeeded:
           if ! wait $pid; then
             status=$?
           fi
         fi
       done

       exit $status
     #+end_src

     /Hush/ proposes a different approach, allowing one to launch a command block
     asynchronously, and have immediate access to the operations regarding such job. When
     a command block is delimited with the =&{}= operator, the block is executed
     asynchronously, and the resulting value of the expression is a =dict= with a set of
     values and functions to operate on the job:
     - ~pid~: the job's =pid=. You are unlikely to need this field in practice.
     - ~running()~: returns a =bool= indicating whether the job is still running.
     - ~abort()~: aborts the job, killing any child processes.
     - ~join()~: like /Bash/'s =wait=, blocks until the job is finished, and returns the job's
       status code.

     Hush:
     #+begin_src lua
       -- Array variable to capture the pids of all spawned tasks
       let jobs = []

       let job = &{ one long running command }
       jobs.push(job)

       job = &{ another long running command }
       jobs.push(job)

       job = &{ yet another long running command }
       jobs.push(job)

       -- Give jobs some time to complete
       sleep(2000)

       let status = 0

       for job in iter(jobs) do
         if job.running() then
           -- Job is stil running, abort...
           job.abort()
           status = 1
         else
           -- Job finished, check if succeeded:
           let job_status = job.join()
           if job_status != 0 then
             status = job_status
           end
         end
       end

       exit(status)
     #+end_src
** Object model
   /Hush/ mainly focuses on functional programming, but also supports some sort of object
   oriented programming. While /Lua/ proposes the /metatable/ mechanism to add sofisticated dynamics
   to /tables/, /Hush/ adopts simpler semantics, having /dicts/ as plain key-value stores.

   Functions can act as methods by using the ~self~ operator, as described
   previously. Objects can be defined as /dicts/ with member functions, which can be defined
   by a constructor function.

   Hush:
   #+begin_src lua
     function MyCounter(initial_value) -- MyCounter is a function that represents a Class.
       let increment = function()
         self._value += 1
       end

       let get = function()
         return self._value
       end

       return #[
         _value: initial_value, -- Public field.
         -- These methods could be implemented here as well.
         -- Remeber, functions are nothing but values.
         increment: increment, -- Method
         get: get,             -- Method
       ]
     end


     let counter = MyCounter(0)
     counter.increment()
     counter.increment()
     counter.get() -- Returns 2


     function StepCounter(initial_value, step)
       -- This function captures the `step` variable, which acts as a private field.
       let increment = function()
         self._value += step
       end

       let print = function()
         print(self.get())
       end

       let counter = MyCounter(initial_value) -- Inheritance
       counter.print = print -- Additional method
       counter.increment = increment -- Method overriding
       return counter
     end


     let counter = StepCounter(0, 2)
     counter.increment()
     counter.increment()
     counter.print() -- Prints 4
   #+end_src
